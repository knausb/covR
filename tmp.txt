

  // Input matrix
  const RcppParallel::RMatrix< Rcpp::String > inmat;
//  const RcppParallel::RMatrix< std::string > inmat;
  
//    const RcppParallel::RVector< std::string > invect;
//    const RVector< Rcpp::String > invect;
    
  // Output matrix
  RcppParallel::RMatrix< int > outmat;
    
  // Threshold
  int qmin;
    
  // initialize from Rcpp input and output matrixes (the RMatrix class
  // can be automatically converted to from the Rcpp matrix type)
  // Can't figure out how to initialize the Vector constructor.
//    bafstats_p(const Rcpp::StringVector invect, Rcpp::IntegerMatrix outmat) : invect(invect), outmat(outmat) {}
//    bafstats_p(const Rcpp::StringMatrix invect, Rcpp::IntegerMatrix outmat) : inmat(inmat), outmat(outmat) {}
//  bafstats_p(const Rcpp::StringMatrix inmat, Rcpp::IntegerMatrix outmat, int qmin) 
//    : inmat(inmat), outmat(outmat), qmin(qmin) {}
  bafstats_p(const Rcpp::StringMatrix inmat, Rcpp::IntegerMatrix outmat, int qmin) 
    : inmat(inmat), outmat(outmat), qmin(qmin) {}


/*
  // function call operator that work for the specified range (begin/end)
  void operator()(std::size_t begin, std::size_t end) {
    for (std::size_t i = begin; i < end; i++) {
          
      // Input data
//      std::string ref   = inmat(i,0);
//      std::string calls = inmat(i,1);
//      std::string quals = inmat(i,2);
          
      // row we will operate on
      RcppParallel::RMatrix< int >::Row row2 = outmat.row(i);

/*
      for(int j = 0; j < calls.size(); j++){
        // Convert ascii to int
        // http://www.dreamincode.net/forums/topic/16088-c-how-to-convert-ascii-to-intergers/
        int qual = static_cast<int>(quals[i]);
        qual = qual - 33;
        if(qual >= qmin){
          if(calls[i] == '.'){
            if(ref == "A"){
              row2[0]++;
            } else if(ref == "C"){
              row2[1]++;
            } else if(ref == "G"){
              row2[2]++;
            } else if(ref == "T"){
              row2[3]++;
            } else if(ref == "N"){
              row2[4]++;
            }
          } else if (calls[i] == ','){
            if(ref == "A"){
              row2[6]++;
            } else if(ref == "C"){
              row2[7]++;
            } else if(ref == "G"){
              row2[8]++;
            } else if(ref == "T"){
              row2[9]++;
            } else if(ref == "N"){
              row2[10]++;
            }
          } else if (calls[i] == 'A'){
            row2[0]++;
          } else if (calls[i] == 'C'){
            row2[1]++;
          } else if (calls[i] == 'G'){
            row2[2]++;
          } else if (calls[i] == 'T'){
            row2[3]++;
          } else if(calls[i] == 'N'){
            row2[4]++;
          } else if(calls[i] == '*'){
            row2[5]++;
          } else if(calls[i] == 'a'){
            row2[6]++;
          } else if(calls[i] == 'c'){
            row2[7]++;
          } else if(calls[i] == 'g'){
            row2[8]++;
          } else if(calls[i] == 't'){
            row2[9]++;
          } else if(calls[i] == 'n'){
            row2[10]++;
          }
        }
      }
          
      // Load into return matrix
//    outmat.row(i) = row2;
      for(int j = 0; j < row2.length(); j++){
        outmat(i,j) = row2[j];
      }
*/          
//    }

//  }




