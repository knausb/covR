# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @name baf_stats
#' @title baf_stats
#' @rdname baf_stats
#' 
#' @param calls vector of pileup calls
#' @param quals vector of pileup calls
#' @param ref vector of reference alleles
#' @param minq minimum quality for call to be retained
#' 
#' @details
#' The reference alleles must be in all upper case.
#' See \code{toupper} if they are not.
#'
#' @export
baf_stats <- function(calls, quals, ref, minq = 0L) {
    .Call('covR_baf_stats', PACKAGE = 'covR', calls, quals, ref, minq)
}

#' @name baf_stats_st
#' @title baf_stats_st
#' @rdname baf_stats
#' 
#' @export
baf_stats_st <- function(calls, quals, ref, minq = 0L) {
    .Call('covR_baf_stats_st', PACKAGE = 'covR', calls, quals, ref, minq)
}

#' @title Parse data by a bed file
#' @rdname bedify
#' 
#' @description seperate a data matrix by using bed format data.
#' 
#' @param bed matrix of bed format data
#' @param mydata StringMatrix to be sorted
#' 
#' @details
#' 
#' Bed format data contain at least four columns.
#' The first column indicates the chromosome (i.e., supercontig, scaffold, contig, etc.).
#' The second cotains the starting positions.
#' The third the ending positions.
#' The fourth are the names of the features.
#' All subsequent columns are ignored here.
#' In an attempt to optimize performance the data are expected to be formatted as a character matrix.
#' The starting and end positions are converted to numerics internally.
#' 
#' 
#' \href{https://genome.ucsc.edu/FAQ/FAQformat.html#format1}{Bed format} at UCSC
#' 
#' @export
bedify <- function(myBed, myData) {
    .Call('covR_bedify', PACKAGE = 'covR', myBed, myData)
}

rcpp_hello_world <- function() {
    .Call('covR_rcpp_hello_world', PACKAGE = 'covR')
}

#' @title File input/output
#' @name File input/output
#' 
#' @description Fast but featureless input of tabular data in either *.txt or *.gz format.
#' 
#' 
#' @rdname read_matrix
#' @aliases file_stats
#' 
#' @param filename name of a file
#' @param sep character which delimits columns
#' @param nrows number of rows to read
#' @param skip number of rows to skip
#' @param verbose should verbose output be generated
#' 
#' @return \strong{file_stats} returns a three element vector.
#' 'Total_rows' reports the total number of rows read.
#'  This is either the number of rows in the file or the number of skipped rows and the number of rows read in.
#'  'Rows' is the number of rows read in.
#'  This is either the same as nrows or however many rows were read in after skip and before the end of the file (when less than nrows).
#' 
#' @export
file_stats <- function(filename, sep = "\t", nrows = -1L, skip = 0L, verbose = 1L) {
    .Call('covR_file_stats', PACKAGE = 'covR', filename, sep, nrows, skip, verbose)
}

#' @rdname read_matrix
#' @aliases read_matrix
#' 
#' @param ncols number of columns for the matrix
#' 
#' @return \strong{read_matrix} returns a matrix of strings of dimension specified by nrows and ncols.
#' 
#' @seealso
#' \href{http://cran.r-project.org/web/packages/readr/index.html}{readr}
#' \href{http://cran.r-project.org/web/packages/data.table/index.html}{data.table::fread}
#'
#' @export
read_matrix <- function(filename, sep = "\t", nrows = 1L, ncols = 1L, skip = 0L, verbose = 1L) {
    .Call('covR_read_matrix', PACKAGE = 'covR', filename, sep, nrows, ncols, skip, verbose)
}

parallelVectorSum <- function(x) {
    .Call('covR_parallelVectorSum', PACKAGE = 'covR', x)
}

#' @name write_matrix
#' @title write_matrix
#' @rdname write_matrix
#' 
#' @param filename filename for output
#' @param mymatrix matrix to be written to file
#' @param sep delimiting character
#' @param verbose should verbose output be generated?
#'
#'
#' @export
write_matrix <- function(filename, mymatrix, sep = "\t", verbose = 1L) {
    invisible(.Call('covR_write_matrix', PACKAGE = 'covR', filename, mymatrix, sep, verbose))
}

