# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @name baf_stats
#' @title baf_stats
#' @rdname baf_stats
#' 
#' @param calls vector of pileup calls
#' @param quals vector of pileup calls
#' @param ref vector of reference alleles
#' @param minq minimum quality for call to be retained
#' 
#' @details
#' The reference alleles must be in all upper case.
#' See \code{toupper} if they are not.
#'
#' @export
baf_stats <- function(calls, quals, ref, minq = 0L) {
    .Call('covR_baf_stats', PACKAGE = 'covR', calls, quals, ref, minq)
}

#' @name baf_stats_st
#' @title baf_stats_st
#' @rdname baf_stats
#' 
#' @param inMatrix input matrix
#' 
#' @details The character matrix \strong{inMatrix} should consist of columns  5 columns. 
#' The first column is the chromosome name (and is not presently used).
#' The second column is the chromosomal position.
#' The third column is the reference allele.
#' The fourth column is a string of calls.
#' The fifth column is a string of qualities.
#' This is expected to come from mpileup output.
#' Note that while mpileup can include data for multiple samples, here we need to process each sample seperately.
#' 
#' @export
baf_stats_st <- function(inMatrix, minq = 0L) {
    .Call('covR_baf_stats_st', PACKAGE = 'covR', inMatrix, minq)
}

#' @title Parse data by a bed file
#' @rdname bedify
#' 
#' @description Seperate a data matrix into list elements based on coordinates from bed format data.
#' 
#' @param myBed matrix of bed format data
#' @param myData StringMatrix or IntegerMatrix to be sorted
#' 
#' @details
#' 
#' \strong{Bed format} data contain at least four columns.
#' The first column indicates the chromosome (i.e., supercontig, scaffold, contig, etc.).
#' The second cotains the starting positions.
#' The third the ending positions.
#' The fourth are the names of the features.
#' All subsequent columns are ignored here.
#' In an attempt to optimize performance the data are expected to be formatted as a character matrix.
#' The starting and end positions are converted to numerics internally.
#' 
#' The \strong{matrix format} used here is based on vcf type data.
#' Typically these data have a chromosome as the first column.
#' Each chromosome has its own coordinate system which begins at one.
#' This means that using multiple chromosomes will necessitate some fix to the coordinate systems.
#' Here I take the perspective that you should simply work on one chromosome at a time, so the chromosome information is ignored.
#' The first column is the chromosome, which I ignore.
#' The second column is the position, which is used for sorting.
#' Subsequent columns are not treated but are brought along with the subset.
#' 
#' 
#' When the matrix is of numeric form the first column, which contains the chromosome identifier (CHROM), must also be numeric.
#' This is because matrix elements must all be of the same type.
#' 
#' 
#' 
#' \href{https://genome.ucsc.edu/FAQ/FAQformat.html#format1}{Bed format} at UCSC
#' 
#' @export
bedify <- function(myBed, myData) {
    .Call('covR_bedify', PACKAGE = 'covR', myBed, myData)
}

#' @title Parse data by a bed file
#' @rdname bedify
#' 
#' 
#' @export
bedify_sm <- function(myBed, myData) {
    .Call('covR_bedify_sm', PACKAGE = 'covR', myBed, myData)
}

#' @title Parse data by a bed file
#' @rdname bedify
#' 
#' 
#' @export
bedify_nm <- function(myBed, myData) {
    .Call('covR_bedify_nm', PACKAGE = 'covR', myBed, myData)
}

rcpp_hello_world <- function() {
    .Call('covR_rcpp_hello_world', PACKAGE = 'covR')
}

#' @title File input/output
#' @name File input/output
#' 
#' @description Fast but featureless input of tabular data in either *.txt or *.gz format.
#' 
#' 
#' @rdname read_matrix
#' @aliases file_stats
#' 
#' @param filename name of a file
#' @param sep character which delimits columns
#' @param nrows number of rows to read
#' @param skip number of rows to skip
#' @param verbose should verbose output be generated
#' 
#' @return \strong{file_stats} returns a three element vector.
#' 'Total_rows' reports the total number of rows read.
#'  This is either the number of rows in the file or the number of skipped rows and the number of rows read in.
#'  'Rows' is the number of rows read in.
#'  This is either the same as nrows or however many rows were read in after skip and before the end of the file (when less than nrows).
#' 
#' @export
file_stats <- function(filename, sep = "\t", nrows = -1L, skip = 0L, verbose = 1L) {
    .Call('covR_file_stats', PACKAGE = 'covR', filename, sep, nrows, skip, verbose)
}

#' @rdname read_matrix
#' @aliases read_matrix
#' 
#' @param cols vector of column numbers to include in the matrix
#' 
#' @return \strong{read_matrix} returns a matrix of strings of dimension specified by nrows and ncols.
#' 
#' @seealso
#' \href{http://cran.r-project.org/web/packages/readr/index.html}{readr}
#' \href{http://cran.r-project.org/web/packages/data.table/index.html}{data.table::fread}
#'
#' @export
read_matrix <- function(filename, sep = "\t", nrows = 1L, cols = 0L, skip = 0L, verbose = 1L) {
    .Call('covR_read_matrix', PACKAGE = 'covR', filename, sep, nrows, cols, skip, verbose)
}

parallelVectorSum <- function(x) {
    .Call('covR_parallelVectorSum', PACKAGE = 'covR', x)
}

#' @name write_matrix
#' @title write_matrix
#' @rdname write_matrix
#' 
#' @param filename filename for output
#' @param mymatrix matrix to be written to file
#' @param sep delimiting character
#' @param verbose should verbose output be generated?
#'
#'
#' @export
write_matrix <- function(filename, mymatrix, sep = "\t", verbose = 1L) {
    invisible(.Call('covR_write_matrix', PACKAGE = 'covR', filename, mymatrix, sep, verbose))
}

